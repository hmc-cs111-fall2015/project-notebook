# Design notebook for week ending November 2, 2014

## Description

###10/28/15

10-10:20a
Read over the project description.

The first thing to do is to see if Scala has image processing libraries.
I lied, the first first thing to do is to set up the repositories.
And come up with a project name.

FreeTile. Done.

###10/29/15

12:45-3:15p

Start by making the project repository.
Now to search for image processing libraries so that I can make the project description/plan.
Found one. Will ask Prof Ben about it, then start on the project description.

In filling out the language design and example computations part, I wrote a lot before reading that I shouldn't be describing the syntax of the program. This text will be put here, so that I won't lose it in case I need it later:

```
debugging = True
tile water1 = SRCPATH
tile ground1 = SRCPATH {
	edge = SRCPATH
}
freeform tile house = SRCPATH
freeform tile peninsula = SRCPATH {
	anchor = (0,200)
}
map {
	width = 750
	height = 750
	origin = bottomLeft

	layer 0 = {
		fill water1
	}
	layer 1 = {
		from (0,250) to (250,750) fill ground1
	}
	layer 2 = {
		at (250,250) place peninsula
		at [(100, 650), (250, 600), (400, 300)] place house
	}
}
generate map as FILENAME
generate debug map as FILENAME
```


``map`` is somewhat akin to a ``main`` function, though if it is more natural to the users to think of a map in the same way as the tiles, it may be possible to specify the tiles and map, and then specify each layer outside of the map object.
Either way, only one map can exist per program.

No origin specified assumes top left, as is standard for image processing.
There probably won't be implementation that allows for the origin to be on the right-hand side of the image, but ``origin = bottomLeft`` seems more intuitive than ``origin = bottom``. (This can change, of course.)

Given no ``from`` keyword, ``fill`` will fill the entire layer.

The ``from`` keyword assumes it will be given two opposite points of a rectangle to fill in.
Some more planning must be done for other shapes, besides adding multiple froms. It seems best to allow users to specify a list of points to carve out a space to fill in, as well as letting them "draw a line" that divides the area and specify which side to fill in.


I'm going back and forth on whether or not there should be a ``return`` statement. It's given that once you specify a map and output is on, it'll return something.
Having output be a flag seems ridiculous, actually. They should just have to use ``return``, and if they don't, it'll give a warning but not an error (as they may want to debug before producing a map).

Also, they should have to specify what to name the output map.
I may not go so far as to give a warning if something with that name already exists; that would be implemented in the GUI.


This wasn't thought out enough to put in the design file:
A big consideration, since there are no limits to how a user can layer the images, is how to make this run efficiently. With time constraints, optimization may not happen, but ideally the map wouldn't be generated by just copying each layer over and overwriting the previous ones. Using an image library, this may be the only way.

Essentially, the options are to write in each layer's pixels at the right place in the output image, which would be O(MN^L) reads and writes - M and N are width and height, L is the number of layers - or to just go across each pixel in the output image and check each layer until the topmost one with a value there is found. This is still O(MN^L) reads, but only O(MN) writes.
In the end, it probably isn't worth it.

Something that just occured to me is that, say, hexagonal tiles may be useful. I'm not sure how, or if, I could integrate that into this project, but 

I need to check how to save "in a current directory." Maybe a SRCPATH will be given for generating a map. It would be consistent, at least.

The user doesn't have to name the debug map; it will have a standard name.However, if they want to keep multiple ones for different maps, they can name them whatever they want.

###10/30/15
2:15-4:30p

The library has been approved!

Finished with plan.md. Next, I'll work on a preliminary grammar... or, at least, keywords and what they do. A grammar here probably won't be that helpful!

2:15-3:30p

The library has been approved!

Finished with plan.md.



## Questions

**What is the most pressing issue for your project? What design decision do
you need to make, what implementation issue are you trying to solve, or how
are you evaluating your design and implementation?**

Decide on a host language: Scala or Python.
Python has the existing image libraries, though language design would be more difficult.
Scala has the reverse situation.
Honestly, I'm most likely to go with Scala since that's where I have practice designing an external DSL.

If Prof Ben greenlights the library I found, Scala it is!

The two things to focus on are a formal grammar + intermediate representation and, more importantly, how the image processing end will work.

**What questions do you have for your critique partners? How can they best help
you?**

I'm not supposed to focus on semantics right now, but any feedback on the keywords is appreciated.

**How much time did you spend on the project this week? If you're working in a
team, how did you share the labor?**

4 hours, 5 minutes.

## Post-critique summary


## Post-critique reflection
